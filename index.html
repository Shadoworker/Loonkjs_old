<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoonkJS - PEN TOOL</title>
</head>

<body>

    <style>
        body {
            margin: 0px;
        }

        svg#svg{
            width: 800px; 
            height: 600px; 
            border:solid;
        }
        div#centering
        {
            display: flex;
            /* justify-content: center;  */
        }

    </style>


    <div id="centering">
        <svg id="svg" >
            <path id="path" d="" fill="none" stroke-width="3" stroke="black" />
        </svg>
    </div>


    <script>




        class Point {
            constructor(_type, _values) {
                this.type = _type;
                this.values = _values;
            }


            toString() // Return point equivalent in svg (M or c)
            {
                var _vals = "";
                for (let i = 0; i < this.values.length; i+=2) 
                {
                    const p1 = this.values[i];
                    const p2 = this.values[i+1];

                    _vals += p1 + "," + p2 + " ";
                }

                return this.type+_vals;
            }
            getPos() // Getting the position of this point (x,y)
            {
                var _l = this.values.length;
                var pos = {
                    x : this.values[_l-2], 
                    y: this.values[_l-1]
                };

                return pos; 
            }
            setPos(_diffX, _diffY)
            {
            //   for (let i = 0; i < (this.values.length/2); i++) 
            //   {
                // TODO : Check later for curve bezier values to update ...
                var l = this.values.length;
                this.values[l-2] = _diffX;
                this.values[l-1] = _diffY;
            //   }
            }
        }

        /* --------- STATES ------------ */
        const DRAWING_STATES = {
            NONE : 1,
            DRAWING : 2,
            UPDATING : 3,
            CURVING : 4
        }

        const MOUSE_STATES = {
            CLICKED : 1,
            DOUBLECLICKED : 2,
            DRAGING : 3,
            MOVING : 4,
            ENDED : 5,
            NONE : 6
        }

        /* ---------- STATES end --------- */



        // var p2 = new Point("c", [0, 0, 0, 0, (120+2), (140+2)])
        // console.log(p2.toString())

        const MINIMAL_MOVE  = 5;
        const DOT_MARGIN    = 2;
        const DOUBLE_CLICK_DELAY = 250; //ms : 250 seem to be the smallest value between two taps

        var m_svgBox = document.getElementById("svg");
            m_path = document.getElementById("path"),
            m_points = [], // Keep drawing points reference : for updates
            m_isDrawing = false , 
            m_isFirstPoint = true,
            m_triggeredNewPoint = false,
            m_startDrag = false,
            m_isDraging = false,
            m_clickProcessed = false,
            m_mouseState = MOUSE_STATES.NONE,
            m_drawingState = DRAWING_STATES.NONE;
       
        var SVG_MARGIN_X = m_svgBox.getBoundingClientRect().left;


        // // Listen for mousedown event on svg
        m_svgBox.addEventListener("click", draw);

        // // Listen for mousemove event on svg
        m_svgBox.addEventListener("mousemove", updateDrawing);

        // // Listen for drawing end
        document.body.addEventListener("keypress", stopDrawing);


        // Trigger Draw on SVG
        var timer;
        var tapCount = 0;
        function draw(e)
        {
            m_mouseState = MOUSE_STATES.NONE;

            var tapCount = e.detail;

            // console.log(e.detail)
            if(tapCount == 1)
                timer = setTimeout(()=>{
                    tapCount = 0;
                    
                    if(m_mouseState != MOUSE_STATES.DOUBLECLICKED || m_mouseState != MOUSE_STATES.DRAGING)
                    {    
                        m_mouseState = MOUSE_STATES.CLICKED;
                        // console.log("CLICK")
                        m_clickProcessed = true;

                        if(m_isFirstPoint)
                        {
                            startDrawing(e);
                            // Update path : Init
                            updatePath();
                        }
                        else
                        {
                            proceedDrawing(e);
                        }

                    }

                },DOUBLE_CLICK_DELAY)
            if(tapCount >= 2)
            {
                if(timer)
                    clearTimeout(timer);
                tapCount = 0;
                
                m_mouseState = MOUSE_STATES.DOUBLECLICKED;
                m_drawingState = DRAWING_STATES.CURVING;

                console.log("CLICKx2")
            }

            // if(m_startDrag) return;


            // if(m_isFirstPoint)
            // {
            //     startDrawing(e);
            //     // Update path : Init
            //     updatePath();
            // }
            // else
            // {
            //     proceedDrawing(e);
            //     console.log("NEXT");
            // }
        }

       
       
        // Create a closer point to the current one in order to prepare the next one
        function createStartingPoint(_lastPointX, _lastPointY)
        {
            return new Point("C", [_lastPointX, _lastPointY, _lastPointX, _lastPointY, (_lastPointX + DOT_MARGIN), (_lastPointY + DOT_MARGIN)])
        }
        // // Function to start drawing
        function startDrawing(e) {
         
            m_drawingState = DRAWING_STATES.DRAWING;

            var _x = e.clientX - SVG_MARGIN_X;
            var _y = e.clientY;
            // Starting Point
            var p1 = new Point("M", [_x, _y])
            var p2 = createStartingPoint(_x, _y);
            // console.log(p2)
            // New points
            m_points.push(p1,p2);
            // startDrawing(e)
            m_isFirstPoint = false;
            console.log("FIRST");

        }

        function proceedDrawing(e) {

          if (m_drawingState != DRAWING_STATES.DRAWING) return; // stop the function when drawmode left
          
            console.log("NEXT");

            m_triggeredNewPoint = true;

            // Create next point : Closer to the current one
            var lastPoint = m_points[(m_points.length-1)];
            var lpos = lastPoint.getPos();
            var startingPoint = createStartingPoint(lpos.x, lpos.y);

            var _x = e.clientX - SVG_MARGIN_X + DOT_MARGIN;
            var _y = e.clientY + DOT_MARGIN;
            
            var diffX = _x - lpos.x ;
            var diffY = _y - lpos.y;
            var worthIt = (Math.abs(diffX) > MINIMAL_MOVE || Math.abs(diffY) > MINIMAL_MOVE );
            
           
            m_points.push(startingPoint);

            // Update path
            updatePath();

            m_triggeredNewPoint = false;

        }

        function updateDrawing(e)
        {
            // if(m_isDraging)
            // {
            //     console.log("DRAGING POINT")

            //     return;
            // }

            if(m_drawingState != DRAWING_STATES.DRAWING || m_triggeredNewPoint) return;

            
            if(m_mouseState == MOUSE_STATES.CLICKED)
            {
                var _x = e.clientX - SVG_MARGIN_X;
                var _y = e.clientY;
                
                var result = addNewPoint(_x, _y);
                var worthIt = result.worthIt;
                var newPoint = result.point;

                if(!worthIt) return;
                
                console.log("UPDATING")
            
                // Update points
                m_points[(m_points.length-1)] = newPoint;

                // Update path
                updatePath();

            }

           

        }


        function dragingPoint(e)
        {
            clearTimeout(timer)
            console.log('dblclick')
            // if(m_startDrag)
            // {
            //     console.log("DRAG STARTED")
            //     m_isDraging = true;
            // }
          

        }

        function addNewPoint(_x, _y, _isUpdating = false)
        { 
            
            var lastPoint = m_points[(m_points.length-1)];
            var prevPoint = m_points[(m_points.length-2)];
            var prevPointPos = prevPoint.getPos();
            var x = prevPointPos.x;
            var y = prevPointPos.y;

            if(!_isUpdating)
            {   
                x = _x ;
                y = _y ;
            }

            lastPoint.setPos(x, y);

            var worthIt = (Math.abs(x) > MINIMAL_MOVE || Math.abs(y) > MINIMAL_MOVE );

            var result = {worthIt : worthIt, point : lastPoint};

            return result;

        }

        // Function to stop drawing
        function stopDrawing(e) {
            if (e.key === "Enter") {
                // Cancel the default action, if needed
                e.preventDefault();
                m_isDrawing = false;
                m_isFirstPoint = true;

                // Remove current startin point from points and update path ()
                m_points.pop();
                updatePath();

                console.log('Quit')
            }
        }

        function updatePath()
        {
            var data = "";

            for (let i = 0; i < m_points.length; i++) {

                const p = m_points[i];
                var pToSvg = p.toString();

                data += pToSvg;                
            }

            m_path.setAttribute("d", data.trimEnd());
        }

        // Listen for mousemove event on canvas
        // canvas.addEventListener("mousemove", setControlPoints);

        // // Function to set control points
        // function setControlPoints(e) {
        // //   if (!m_isDrawing) return;
        //   controlX1 = startX + (e.clientX - SVG_MARGIN_X - startX) / 4;
        //   controlY1 = startY;
        //   controlX2 = startX + 3 * (e.clientX - startX) / 4;
        //   controlY2 = e.clientY;
        // }
    </script>

</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoonkJS - PEN TOOL</title>
</head>

<body>

    <style>
        body {
            margin: 0px;
        }

        svg#svg{
            width: 800px; 
            height: 600px; 
            border:solid;
        }
        div#centering
        {
            display: flex;
            /* justify-content: center;  */
        }

    </style>


    <div id="centering">
        <svg id="svg" >
            <path id="path" d="" fill="none" stroke-width="3" stroke="black" />
        </svg>
    </div>

    <!-- 
        M 0.5 1 C 4 60 16 175 45 175 

        M 0.5 1 C -4 60 -29 175 45 175 
    -->

    <script>




        /* -------- POINT CLASS ------- */

        class Point {
            constructor(_type, _values) {
                this.type = _type;
                this.values = _values;

                // Used for keeping curving point fixed
                this._initX = null;
                this._initY = null;

            }

            toString() // Return point equivalent in svg (M or c)
            {
                var _vals = "";
                for (let i = 0; i < this.values.length; i+=2) 
                {
                    const p1 = this.values[i];
                    const p2 = this.values[i+1];

                    _vals += p1 + "," + p2 + " ";
                }

                return this.type+_vals;
            }
            getPos() // Getting the position of this point (x,y)
            {
                var _l = this.values.length;
                var pos = {
                    x : this.values[_l-2], 
                    y: this.values[_l-1]
                };

                return pos; 
            }
            setPos(_diffX, _diffY)
            {
                var l = this.values.length;
                this.values[l-2] = _diffX;
                this.values[l-1] = _diffY;
            }

            saveInitialPos()
            {
                var initialPos = this.getPos();
                this._initX = initialPos.x;
                this._initY = initialPos.y;
            }

            getPrevPointPos()
            {
                return m_points[m_points.indexOf(this) - 1].getPos();
            }

            getCP1Coords()
            {
                var a = m_points[m_points.indexOf(this) - 1].getPos();
                var b = this.getPos();
                // calc line's midpoint
                var midX=a.x+(b.x-a.x)*0.3;
                var midY=a.y+(b.y-a.y)*0.3;

                return {x : midX,  y : midY};
            }

            setCP1Coords(_coords)
            {
                var cp1x = 0, cp1y = 1;
                
                this.values[cp1x] = _coords.x;
                this.values[cp1y] = _coords.y;
            }

            setCP2Coords(_coords)
            {
                var cp2x = 2, cp2y = 3;
                
                this.values[cp2x] = _coords.x;
                this.values[cp2y] = _coords.y;
            }

            setCurve(_dragX, _dragY)
            {
               /* X X   X X  0 0 : control points*/ 
                var cp1x = 0, cp1y = 1, 
                    cp2x = 2, cp2y = 3,
                    posx = 4, posy = 5;
 
                var l = this.values.length;

                this.values[cp1x] = (this._initX - _dragX);
                this.values[cp1y] = (this._initY - (_dragY * 1));

                this.values[cp2x] = (this._initX - _dragX);
                this.values[cp2y] = (this._initY - (_dragY * 1));

                // Reset pos to initial one
                this.values[posx] = this._initX;
                this.values[posy] = this._initY;

            }




        }

        /* ------ POINT CLASS end ------ */

        /* --------- STATES ------------ */
        const DRAWING_STATES = {
            NONE : 1,
            DRAWING : 2,
            UPDATING : 3,
            CURVING : 4
        }

        const MOUSE_STATES = {
            CLICKED : 1,
            DOUBLECLICKED : 2,
            DRAGING : 3,
            MOVING : 4,
            ENDED : 5,
            NONE : 6
        }

        /* ---------- STATES end --------- */

 
        const MINIMAL_MOVE  = 5;
        const DOT_MARGIN    = 2;
        const DOUBLE_CLICK_DELAY = 300; //ms : 250 seem to be the smallest value between two taps

        var m_svgBox = document.getElementById("svg");
            m_path = document.getElementById("path"),
            m_points = [], // Keep drawing points reference : for updates
            m_isDrawing = false , 
            m_isFirstPoint = true,
            m_triggeredNewPoint = false,
            m_startDrag = false,
            m_isDraging = false,
            m_clickProcessed = false,
            m_mouseState = MOUSE_STATES.NONE,
            m_drawingState = DRAWING_STATES.NONE,
            m_addedCurvePointStarter = false, // Ctrl for curve creation onDrag
            m_dragStartPos = {x : null, y : null};
            ;

       
        var SVG_MARGIN_X = m_svgBox.getBoundingClientRect().left;


        // // Listen for mousedown event on svg
        m_svgBox.addEventListener("mousedown", draw);

        // // Listen for mousemove event and drag on svg
        m_svgBox.addEventListener('mousemove', (e) => {
            if(e.buttons == 1) 
            {
                e.preventDefault();
                // console.log("DRAGING...")
                m_mouseState = MOUSE_STATES.DRAGING;

                proceedCurve(e);
            }
            else
            {
                updateDrawing(e);
            }
        });

        // Left click state or Draging State
        m_svgBox.addEventListener("mouseup", pauseDrawing);

        // // Listen for drawing end
        document.body.addEventListener("keypress", stopDrawing);


        // Trigger Draw on SVG
        function draw(e)
        {
            m_mouseState = MOUSE_STATES.NONE;
                    
            if(m_mouseState != MOUSE_STATES.DOUBLECLICKED || m_mouseState != MOUSE_STATES.DRAGING)
            {    
                m_mouseState = MOUSE_STATES.CLICKED;

                m_clickProcessed = true;

                if(m_isFirstPoint)
                {
                    startDrawing(e);
                }
                else
                {
                    proceedLine(e);
                }

            }

        }

       
       
        // Create a closer point to the current one in order to prepare the next one
        function createStartingPoint()
        {
            var lastPoint = m_points[(m_points.length-1)];
            var lpos = lastPoint.getPos();
           
            var p = new Point("C", [lpos.x, lpos.y, lpos.x, lpos.y, (lpos.x + DOT_MARGIN), (lpos.y + DOT_MARGIN)])

            var result = {lastPointPos : lpos, startingPoint : p};

            return result;
        }
        // // Function to start drawing
        function startDrawing(e) {
         
            m_drawingState = DRAWING_STATES.DRAWING;

            var _x = e.clientX - SVG_MARGIN_X;
            var _y = e.clientY;
            // Starting Point
            var p1 = new Point("M", [_x, _y])
            m_points.push(p1); // Next point require a reference
            const {startingPoint} = createStartingPoint();
            m_points.push(startingPoint);
            
            // Update path : Init
            updatePath();

            m_isFirstPoint = false;
            console.log("FIRST");

        }

        function proceedLine(e) {

          if (m_drawingState != DRAWING_STATES.DRAWING || m_mouseState == MOUSE_STATES.DRAGING) return; // stop the function when drawmode left
          
            console.log("LINE");

            m_triggeredNewPoint = true;

            // Create next point : Closer to the current one
           
            const {lastPointPos, startingPoint} = createStartingPoint();

            var _x = e.clientX - SVG_MARGIN_X + DOT_MARGIN;
            var _y = e.clientY + DOT_MARGIN;
            
            var diffX = _x - lastPointPos.x ;
            var diffY = _y - lastPointPos.y;
            var worthIt = (Math.abs(diffX) > MINIMAL_MOVE || Math.abs(diffY) > MINIMAL_MOVE );
            
            // m_points.push(startingPoint);

            // Update path
            updatePath();

            m_triggeredNewPoint = false;
          

        }


        function proceedCurve(e) {

            /*LOGIC :
                - Add a new starting point (TO BE MOVED WHILE DRAGING - ref : mouseMove) ✓
                - Set control point 1               ✓
                - Set control point 2               ✓
                - Prevent point pos from moving     ✓
            */
            
            if (m_drawingState != DRAWING_STATES.DRAWING && m_mouseState != MOUSE_STATES.DRAGING) return; // stop the function when drawmode left

            var _x = e.clientX - SVG_MARGIN_X;
            var _y = e.clientY;
            
            var result = addNewPoint(_x, _y);
            var worthIt = result.worthIt;
            var newPoint = result.point;

            // Get concerned Points
            // var curvingPoint = m_points[m_points.length - 2];
            var activePoint = m_points[m_points.length - 1];

            if(!m_addedCurvePointStarter) // In order to add only a single one point
            {       
                // Add new point
                // m_points.push(newPoint);
                // Set DragStatPos : Once --------
                m_dragStartPos.x = _x;
                m_dragStartPos.y = _y;
                //-------------------------

                //Save active point initial pos
                activePoint.saveInitialPos();

                //Set first control point : To reset later if straight line
                var initialCP1Pos = activePoint.getCP1Coords();
                activePoint.setCP1Coords(initialCP1Pos);
                // Set second control point ....
                var initialCP2Pos = activePoint.getPos();
                activePoint.setCP2Coords(initialCP2Pos);

                m_addedCurvePointStarter = true; // Leave this loop
            }
          
            // Get Draging distance ---------------
            var lineDist = getDistance(activePoint.getPrevPointPos().x, activePoint.getPrevPointPos().y, m_dragStartPos.x, m_dragStartPos.y);
            var dist = getDistance(_x, _y, m_dragStartPos.x, m_dragStartPos.y);
            
            console.log([lineDist , dist]);

            var _dragX = _x - m_dragStartPos.x;
            var _dragY = _y - m_dragStartPos.y;
            // console.log([_dragX, _dragY])
            // _dragX =  _dragX/Math.abs(_dragX) || 1; // To avoid NAN
            // _dragY =  _dragY/Math.abs(_dragY) || 1; // To avoid NAN
            //--------------------------------------
            // Update Points values to create a curve
            activePoint.setCurve(_dragX, _dragY);  // right

            
            // console.log("DRAGING")
        
            // // Update points
            // m_points[(m_points.length-1)] = newPoint;

            // Update path
            updatePath();



        }

        function updateDrawing(e)
        {

            if(m_drawingState != DRAWING_STATES.DRAWING || m_triggeredNewPoint) return;
            if(m_mouseState == MOUSE_STATES.DRAGING) return;

            
            if(m_mouseState == MOUSE_STATES.CLICKED)
            {
                var _x = e.clientX - SVG_MARGIN_X;
                var _y = e.clientY;
                
                var result = addNewPoint(_x, _y);
                var worthIt = result.worthIt;
                var newPoint = result.point;

                if(!worthIt) return;
                
                console.log("UPDATING")
            
                // Update points
                m_points[(m_points.length-1)] = newPoint;

                // Update path
                updatePath();

            }
 
        }

        // Left click or draging state
        function pauseDrawing(e)
        {

            if(m_mouseState == MOUSE_STATES.DRAGING)
            {
                // reset mouse state
                m_mouseState = MOUSE_STATES.NONE;
                // Reset curve starter
                m_addedCurvePointStarter = false;
            }
            

        }


        function addNewPoint(_x, _y, _isUpdating = false)
        { 
            
            var lastPoint = m_points[(m_points.length-1)];
            var prevPoint = m_points[(m_points.length-2)];
            var prevPointPos = prevPoint.getPos();
            var x = prevPointPos.x;
            var y = prevPointPos.y;

            if(!_isUpdating)
            {   
                x = _x ;
                y = _y ;
            }

            lastPoint.setPos(x, y);

            var worthIt = (Math.abs(x) > MINIMAL_MOVE || Math.abs(y) > MINIMAL_MOVE );

            var result = {worthIt : worthIt, point : lastPoint};

            return result;

        }

        // Function to stop drawing
        function stopDrawing(e) {
            if (e.key === "Enter") {
                // Cancel the default action, if needed
                // e.preventDefault();

                if(m_mouseState != MOUSE_STATES.DRAGING) // Remove last point only when not in Draging
                {
                    // Remove current startin point from points and update path ()
                    m_points.pop();
                }

                m_mouseState = MOUSE_STATES.NONE;
                m_isFirstPoint = true;

                updatePath();

                console.log('QUIT')
            }
        }

        function updatePath()
        {
            var data = "";

            for (let i = 0; i < m_points.length; i++) {

                const p = m_points[i];
                var pToSvg = p.toString();

                data += pToSvg;                
            }

            m_path.setAttribute("d", data.trimEnd());
        }

        function getDistance(xA, yA, xB, yB) { 
            
            var xDiff = xA - xB; 
            var yDiff = yA - yB;

            return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
        }
        // Listen for mousemove event on canvas
        // canvas.addEventListener("mousemove", setControlPoints);

        // // Function to set control points
        // function setControlPoints(e) {
        // //   if (!m_isDrawing) return;
        //   controlX1 = startX + (e.clientX - SVG_MARGIN_X - startX) / 4;
        //   controlY1 = startY;
        //   controlX2 = startX + 3 * (e.clientX - startX) / 4;
        //   controlY2 = e.clientY;
        // }
    </script>

</body>

</html>